/*  This file is part of MD.emu.

	MD.emu is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	MD.emu is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with MD.emu.  If not, see <http://www.gnu.org/licenses/> */

module;
#include "genplus-config.h"
#include "system.h"
#include "state.h"

export module system;
import emuex;
import imagine;
import std;

export extern "C++" t_config config;

namespace EmuEx
{

using namespace IG;

export enum class MdKey: KeyCode
{
	Up = 1,
	Right = 4,
	Down = 2,
	Left = 3,
	Mode = 12,
	Start = 8,
	A = 7,
	B = 5,
	C = 6,
	X = 11,
	Y = 10,
	Z = 9,
};

using CheatCodeString = StaticString<11>;

extern "C++" class CheatCode
{
public:
	CheatCodeString text;
	uint32_t address{};
	uint16_t data{};
	uint16_t origData{};
	uint8_t *prev{};

	constexpr bool operator==(const CheatCode& rhs) const { return text == rhs.text;  }
};

extern "C++" class Cheat
{
public:
	static constexpr size_t maxCheatNameChars = 127;
	StaticString<maxCheatNameChars> name;
	std::vector<CheatCode> codes;
	union
	{
		struct{uint8_t on:1, applied:1;};
		uint8_t flags{};
	};

	bool operator==(Cheat const& rhs) const
	{
		return codes == rhs.codes;
	}
};

enum MdConfigKey
{
	CFGKEY_BIG_ENDIAN_SRAM = 278, CFGKEY_SMS_FM = 279,
	CFGKEY_6_BTN_PAD = 280, CFGKEY_MD_CD_BIOS_USA_PATH = 281,
	CFGKEY_MD_CD_BIOS_JPN_PATH = 282, CFGKEY_MD_CD_BIOS_EUR_PATH = 283,
	CFGKEY_MD_REGION = 284, CFGKEY_VIDEO_SYSTEM = 285,
	CFGKEY_INPUT_PORT_1 = 286, CFGKEY_INPUT_PORT_2 = 287,
	CFGKEY_MULTITAP = 288, CFGKEY_CHEATS_PATH = 289,
};

export bool hasBinExtension(std::string_view name) { return endsWithAnyCaseless(name, ".bin"); }
export bool hasMDCDExtension(std::string_view name) { return endsWithAnyCaseless(name, ".cue", ".iso", ".chd"); }

export bool hasMDExtension(std::string_view name)
{
	return hasBinExtension(name) || endsWithAnyCaseless(name, ".smd", ".md", ".gen"
		#ifndef NO_SYSTEM_PBC
		, ".sms"
		#endif
		);
}

export class MdSystem final: public EmuSystem
{
public:
	std::string cheatsDir;
	int playerIdxMap[4]{};
	int gunDevIdx{};
	int8_t mdInputPortDev[2]{-1, -1};
	int8_t autoDetectedVidSysPAL{};
	int8_t savedVControllerPlayer{-1};
	Property<bool, CFGKEY_BIG_ENDIAN_SRAM> optionBigEndianSram;
	Property<bool, CFGKEY_SMS_FM,
	{
		.defaultValue = true
	}> optionSmsFM;
	Property<bool, CFGKEY_6_BTN_PAD> option6BtnPad;
	Property<bool, CFGKEY_MULTITAP> optionMultiTap;
	Property<int8_t, CFGKEY_INPUT_PORT_1,
	{
		.defaultValue = -1, .isValid = isValidWithMinMax<-1, 4>
	}> optionInputPort1;
	Property<int8_t, CFGKEY_INPUT_PORT_2,
	{
		.defaultValue = -1, .isValid = isValidWithMinMax<-1, 4>
	}> optionInputPort2;
	Property<uint8_t, CFGKEY_MD_REGION,
	{
		.isValid = isValidWithMax<4>
	}> optionRegion;
	Property<uint8_t, CFGKEY_VIDEO_SYSTEM,
	{
		.isValid = isValidWithMax<2>
	}> optionVideoSystem;
	#ifndef NO_SCD
	FS::PathString cdBiosUSAPath, cdBiosJpnPath, cdBiosEurPath;
	#endif
	static constexpr size_t maxSaveStateSize = STATE_SIZE + 4;
	static constexpr FrameRate ntscFrameRate{53693175. / (262. * MCYCLES_PER_LINE)}; // ~59.92Hz
	static constexpr FrameRate palFrameRate{53203424. / (313. * MCYCLES_PER_LINE)}; // ~49.70Hz
	std::vector<Cheat> cheatList;
	std::vector<CheatCode*> romCheatList;
	std::vector<CheatCode*> ramCheatList;
	static constexpr SystemLogger log{"MD.emu"};

	MdSystem(ApplicationContext ctx):
		EmuSystem{ctx} {}
	void setupInput(EmuApp&);
	void writeCheatFile();
	void readCheatFile();
	void applyCheats();
	void clearCheats();
	void clearCheatList();
	void updateCheats();
	void RAMCheatUpdate();
	void ROMCheatUpdate();

	// required API functions
	void loadContent(IO&, EmuSystemCreateParams, OnLoadProgressDelegate);
	[[gnu::hot]] void runFrame(EmuSystemTaskContext, EmuVideo*, EmuAudio*);
	FS::FileString stateFilename(int slot, std::string_view name) const;
	std::string_view stateFilenameExt() const { return ".gp"; }
	size_t stateSize() { return maxSaveStateSize; }
	void readState(EmuApp&, std::span<uint8_t> buff);
	size_t writeState(std::span<uint8_t> buff, SaveStateFlags = {});
	bool readConfig(ConfigType, MapIO&, unsigned key);
	void writeConfig(ConfigType, FileIO&);
	void reset(EmuApp&, ResetMode mode);
	void clearInputBuffers();
	void handleInputAction(EmuApp*, InputAction);
	FrameRate frameRate() const { return videoSystem() == VideoSystem::PAL ? palFrameRate : ntscFrameRate; }
	void configAudioRate(FrameRate outputFrameRate, int outputRate);

	// optional API functions
	void loadBackupMemory(EmuApp&);
	void onFlushBackupMemory(EmuApp&, BackupMemoryDirtyFlags);
	WallClockTimePoint backupMemoryLastWriteTime(const EmuApp&) const;
	void closeSystem();
	bool resetSessionOptions(EmuApp&);
	bool onVideoRenderFormatChange(EmuVideo&, PixelFormat);
	void renderFramebuffer(EmuVideo&);
	void onOptionsLoaded();
	void onSessionOptionsLoaded(EmuApp&);
	bool onPointerInputStart(const Input::MotionEvent&, Input::DragTrackerState, WindowRect gameRect);
	bool onPointerInputUpdate(const Input::MotionEvent&, Input::DragTrackerState dragState,
		Input::DragTrackerState prevDragState, WindowRect gameRect);
	bool onPointerInputEnd(const Input::MotionEvent&, Input::DragTrackerState, WindowRect gameRect);
	VideoSystem videoSystem() const;
	Cheat* newCheat(EmuApp&, const char* name, CheatCodeDesc);
	bool setCheatName(Cheat&, const char* name);
	std::string_view cheatName(const Cheat&) const;
	void setCheatEnabled(Cheat&, bool on);
	bool isCheatEnabled(const Cheat&) const;
	bool addCheatCode(EmuApp&, Cheat*&, CheatCodeDesc);
	bool modifyCheatCode(EmuApp&, Cheat&, CheatCode&, CheatCodeDesc);
	Cheat* removeCheatCode(Cheat&, CheatCode&);
	bool removeCheat(Cheat&);
	void forEachCheat(DelegateFunc<bool(Cheat&, std::string_view)>);
	void forEachCheatCode(Cheat&, DelegateFunc<bool(CheatCode&, std::string_view)>);

private:
	void setupSmsInput(EmuApp&);
	void setupMdInput(EmuApp&);
};

export using MainSystem = MdSystem;

class MdApp final: public EmuApp
{
public:
	MdApp(ApplicationInitParams initParams, ApplicationContext& ctx):
		EmuApp{initParams, ctx}, system_{ctx}
	{
		audio_init(44100, 60);
	}

	auto& system(this auto&& self) { return self.system_; }

private:
	MdSystem system_;
};

export using MainApp = MdApp;

}
